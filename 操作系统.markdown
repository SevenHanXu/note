### 一.进程与线程

#### 1.进行间通信的方式？

**1>管道**

环形缓冲区 允许两个进程以生产者/消费者模型进行通信

读管道：当一个进程试图写管道时，如果有足够的空间，则写请求被立即执行，否则进程被阻塞

写管道：当一个进程试图读管道时，如果读取字节数多于当前管道中的字节数，进程被阻塞

操作系统实现互斥，即一次只有一个进程能访问管道

两种管道：

1)命名管道：共享进程可以不相关

2)匿名管道：只有父子进程才能共享

**2>消息**

每个进程都有一个关联的消息队列，功能类似于信箱

1)发送消息：发送者指定发送消息的类型。试图给一个满队列发送时进程会被阻塞

2)接收消息：接收者可以按先进先出的顺序接收信息；也可以按类型接收；试图从空队列读消息时，进程会被阻塞，试图读取某一类型消息，但是该类型消息不存在时，不会阻塞进程

**3>共享内存**

共享内存是UNIX提供的进程间通信手段中速度最快的一种。共享内存是虚存中由多个进程共享的一个公共内存块。互斥约束不属于共享内存机制的一部分，但必须由使用共享内存的进程提供

**4>信号量**

信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

UNIX System V中的信号量**系统调用**是对semWait和semSignal原语的推广

**5>信号**

信号是用于向一个进程通知发生异步事件的机制。类似于硬件中断，但没有优先级，即内核平等地对待所有的信号。对于同时发送的信号，一次只给进程一个信号，而没有特定的次序

**6>套接字**

套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信

更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

#### 2.进程与线程的区别和联系？

**进程**是操作系统进行资源分配的基本单位

**线程**是调度的基本单位

进程中的所有线程共享该进程的状态和资源，进程和线程的关系如下图：

![屏幕快照 2018-09-20 下午6.55.50](/Users/hanxu/Desktop/blog图片文件/屏幕快照 2018-09-20 下午6.55.50.png)

从性能上比较，线程具有如下优点：

1. 在一个已有进程中创建一个新线程比创建一个全新进程所需的时间要少许多

2. 终止一个线程比终止一个进程花费的时间少

3. 同一进程内线程间切换比进程间切换花费的时间少

4. 线程提高了不同的执行程序间通信的效率（在大多数操作系统中，独立进程间的通信需要内核的介入，以提供保护和通信所需要的机制。但是，由于在同一个进程中的线程共享内存和文件，它们无须调用内核就可以互相通信）

5. 一个程序至少有一个进程、一个进程至少有一个线程

6. 线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

7. 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

8. 多线程：解决多任务同时执行的需求，合理使用CPU资源。多线程的运行是根据CPU切换完成，如何切换由CPU决定，因此多线程运行具有不确定性。

9. 线程池：基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。

#### 3.进程的内存布局？

![屏幕快照 2018-09-20 下午10.12.20](/Users/hanxu/Desktop/blog图片文件/屏幕快照 2018-09-20 下午10.12.20.png)

#### 4.程序状态字PSW

一个或一组处理器寄存器，包含有进程的状态信息

程序[状态寄存器](https://baike.baidu.com/item/%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8)[PSW](https://baike.baidu.com/item/PSW/1878339)是计算机系统的核心部件——[运算器](https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E5%99%A8/2667320)的一部分，PSW用来存放两类信息：一类是体现当前指令执行结果的各种状态信息，如有无进位（CY位），有无溢出（OV位），结果正负（SF位），结果是否为零（ZF位），奇偶标志位（P位）等；另一类是存放控制信息，如允许中断(IF位)，跟踪标志（TF位）等。有些机器中将PSW称为[标志寄存器](https://baike.baidu.com/item/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8)FR（Flag Register）。

#### 5.进程的创建步骤

1>给新进程分配一个唯一的进程标识符

2>给新进程分配空间（包括进程映像中的所有元素）

3>初始化进程控制块

4>设置正确的连接（保存到相应队列）

会导致创建进程的事件：

![屏幕快照 2018-09-21 上午9.14.13](/Users/hanxu/Desktop/blog图片文件/屏幕快照 2018-09-21 上午9.14.13.png)

会导致终止进程的事件：

![屏幕快照 2018-09-21 上午9.14.42](/Users/hanxu/Desktop/blog图片文件/屏幕快照 2018-09-21 上午9.14.42.png)

#### 6.进程的切换

在下列事件中，进程可能把控制权交给操作系统：

![屏幕快照 2018-09-21 上午9.23.44](/Users/hanxu/Desktop/blog图片文件/屏幕快照 2018-09-21 上午9.23.44.png)

**1>系统中断：**

- **中断**：与当前正在运行的进程无关的某种类型的外部事件相关。控制首先转移给中断处理器，做一些基本的辅助工作后，转到与已经发生的特定类型的中断相关的操作系统例程
- **陷阱**：与当前正在运行的进程所产生的错误或异常条件相关。操作系统首先确定错误或异常条件是否是致命的。1）如果是，当前进程被换到退出态，发生进程转换；2）如果不是，动作取决于错误的种类或操作系统的设计，可能会进行一次进程切换或者继续执行当前进程

**2>系统调用：**转移到作为操作系统代码一部分的一个例程上执行。通常，使用系统调用会把用户进程置为阻塞态

进程的切换步骤：

1)保存处理器上下文环境（包括程序计数器和其它寄存器）

2)更新当前处于运行态进程的进程控制块（状态和其它信息）

3)将进程控制块移到相应队列

4)选择另一个进程执行

5)更新所选择进程的进程控制块（包括将状态变为运行态）

6)更新内存管理的数据结构

7)恢复处理器在被选择的进程最近一次切换出运行状态时的上下文环境

#### 7.一个程序从开始到结束的完整过程

![屏幕快照 2018-09-21 上午9.55.44](/Users/hanxu/Desktop/blog图片文件/屏幕快照 2018-09-21 上午9.55.44.png)

#### 8.线程分配什么？TCB控制块？

![屏幕快照 2018-09-20 下午6.55.50](/Users/hanxu/Desktop/blog图片文件/屏幕快照 2018-09-20 下午6.55.50.png)

#### 9.线程共享进程什么？不共享什么？CPU共享吗？

**cpu不共享**

所有线程共享进程的状态和资源

**线程之间 的内存和数据是 公用的，每个线程只有自己的一组CPU指令、寄存器和堆栈，对于线程来说只有CPU里的东西是自己独享的，程序中的其他东西都是跟同一个进程里的其他线程共享的**

**1>线程的共享资源**

1) 堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）

2) 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的

3) 静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的

4) 文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。

**2>线程独有的资源**

1）线程ID 每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。

2）寄存器组的值 由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。

3）线程的堆栈  堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程 必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。

4）错误返回码  由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用 后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。    所以，不同的线程应该拥有自己的错误返回码变量。

5）线程的信号屏蔽码  由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。

6）线程的优先级 由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。

#### 10.怎样保证一个CPU只有一个线程运行？

单核CPU电脑同一时间内只能执行一个线程，首先了解一下，CPU执行的过程 ，它是把时间分成若干个小时间段，这些时间段很小的，系统中有很多进程，每个进程中又包含很多线程，在同一 时间段 内，电脑CPU只能处理一个线程（线程A），而下一个 时间段 就不一定是上一个时间段内执行的那个线程（线程A）了，可能是别的线程（线程B 吧）

CPU采用的是类似于时间片轮转的机制，也就是说同一时间一条进程提出执行请求时，其他进程只能等待它执行完毕，CPU才会处理其他请求。其他进程相当于在排队等待中。当然了，为了避免某条进程无限制时间的执行，一般会限定一个时间，超时 的话，CPU根据一定的线程调度算法来切换线程。可以看做很多线程在并发执行。其实还是在某一个时间点上只有一个线程在运行罢了。 
多核的话，每个核心都是同样的原理。但是两个核心就可以通过系统分配资源，同时执行不同的进程，这个就更复杂了。 
每条进程都有CPU分配的进程号的。避免混乱。

一个核心就是实实在在的一个cpu处理设备 线程的概念可以理解成电脑处理信息的通道 既一个线程一个通道 一般来说一个cpu核心处理一个通道的信息 但也不是绝对 因特尔支持超线程技术的cpu每个核心可以处理两个或多个通道的信息 这就可以形容为超线程（既多出来的通道的处理能力）但前提是软件也必须的支持超线程才行 否则单核双线程或多线程也只能有单个通道工作 从某种意义上来说cpu的能力被浪费了 所以网友一般就会说 真正的核心数（通道） 比虚拟出来的核心（通道）来个更实在。最后 线程数决定这CPU能同时处理几件事情，在没有超线程技术的情况下核心数等於线程数。

#### 11.线程有什么状态？

和进程一样，线程的关键状态有运行态、就绪态和阻塞态。一般来说，挂起态对线程没有什么意义。这是由于此类状态是一个进程级的概念。特别地，如果一个进程被换出，由于它的所有线程都共享该进程的地址空间，因此它们必须都被换出

有4种与线程相关的基本操作：

**派生**：在典型情况下，当派生一个新进程时，同时也为该进程派生了一个线程。随后，进程中的线程可以在同一进程中派生另一个线程，并为新线程提供指令指针和参数；新线程拥有自己的寄存器上下文和栈空间，且被放置在就绪队列中

**阻塞**：当线程需要等待一个事件时，它将被阻塞（保存它的用户寄存器、程序计数器和栈指针），此时处理器转而执行另一个处于同一进程中或不同进程中的就绪线程

**解除阻塞**：当阻塞一个线程的事件发生时，该线程被转移到就绪队列中

**结束**：当一个线程完成时，其寄存器上下文和栈都被释放

#### 12.线程池的了解、优点、调度处理方式和保护任务队列的方式？

**1>了解**

 目前的大多数网络服务器，包括Web服务器、Email服务器以及数据库服务器等都具有一个共同点，就是单位时间内必须处理数目巨大的连接请求，但处理时间却相对较短。 
传统多线程方案中我们采用的服务器模型则是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么服务器将处于不停的创建线程，销毁线程的状态。

我们将传统方案中的线程执行过程分为三个过程：T1、T2、T3。

T1：线程创建时间 
T2：线程执行时间，包括线程的同步等时间 
T3：线程销毁时间

那么我们可以看出，线程本身的开销所占的比例为(T1+T3) / (T1+T2+T3)。如果线程执行的时间很短的话，这比开销可能占到20%-50%左右。如果任务执行时间很频繁的话，这笔开销将是不可忽略的。

​      除此之外，线程池能够减少创建的线程个数。通常线程池所允许的并发线程是有上界的，如果同时需要并发的线程数超过上界，那么一部分线程将会等待。而传统方案中，如果同时请求数目为2000，那么最坏情况下，系统可能需要产生2000个线程。尽管这不是一个很大的数目，但是也有部分机器可能达不到这种要求。

**2>优点**
​      基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小，不过我们另外可能需要考虑进去线程之间同步所带来的开销。

**3>调度处理方式**

​	因此线程池的出现正是着眼于减少线程池本身带来的开销。线程池采用预创建的技术，在应用程序启动之后，将立即创建一定数量的线程(N1)，放入空闲队列中。这些线程都是处于阻塞（Suspended）状态，不消耗CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中运行。当N1个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。 

**4>保护任务队列的方式**

存在两个链表，一个是**空闲链表**，一个是**忙碌链表**。空闲链表中存放所有的空闲进程，当线程执行任务时候，其状态变为忙碌状态，同时从空闲链表中删除，并移至忙碌链表中。

线程池中容纳的线程数目并不是一成不变的，其会根据执行负载进行自动伸缩。

为此在ThreadPool中设定四个变量：

m_InitNum：初始创建时线程池中的线程的个数。

m_MaxNum:当前线程池中所允许并发存在的**线程的最大数目**。

m_AvailLow:当前线程池中所允许存在的**空闲线程的最小数目**，如果空闲数目低于该值，表明负载可能过重，此时有必要增加空闲线程池的数目。实现中我们总是将线程调整为m_InitNum个。

m_AvailHigh：当前线程池中所允许的**空闲的线程的最大数目**，如果空闲数目高于该值，表明当前负载可能较轻，此时将删除多余的空闲线程，删除后调整数也为m_InitNum个。

m_AvailNum：目前线程池中**实际存在的线程的个数**，其值介于m_AvailHigh和m_AvailLow之间。如果线程的个数始终维持在m_AvailLow和m_AvailHigh之间，则线程既不需要创建，也不需要删除，保持平衡状态。因此如何设定m_AvailLow和m_AvailHigh的值，使得线程池最大可能的保持**平衡态**，是线程池设计必须考虑的问题。

线程池在接受到新的任务之后，线程池首先要检查是否有足够的空闲线程可用。检查分为三个步骤：

(1)检查当前处于忙碌状态的线程是否达到了设定的最大值m_MaxNum，如果达到了，表明目前没有空闲线程可用，而且也不能创建新的线程，因此必须等待直到有线程执行完毕返回到空闲队列中。

(2)如果当前的空闲线程数目小于我们设定的最小的空闲数目m_AvailLow，则我们必须创建新的线程，默认情况下，创建后的线程数目应该为m_InitNum，因此创建的线程数目应该为(当前空闲线程数与m_InitNum之差;但是有一种特殊情况必须考虑，就是现有的线程总数加上创建后的线程数可能超过m_MaxNum，因此我们必须对线程的创建区别对待。 
**如果创建后总数不超过m_MaxNum，则创建后的线程为m_InitNum；如果超过了，则只创建( m_MaxNum-当前线程总数 )个。**

(3)调用GetIdleThread方法查找空闲线程。如果当前没有空闲线程，则挂起；否则将任务指派给该线程，同时将其**移入忙碌队列**。

当线程执行完毕后，其会调用MoveToIdleList方法**移入空闲链表中**，其中还调用m_IdleCond.Signal()方法，**唤醒GetIdleThread()中可能阻塞的线程。**

**5>线程池适用场景**

(1) 单位时间内处理任务**频繁**而且任务处理时间短

(2) 对**实时**性要求较高。如果接受到任务后在创建线程，可能满足不了实时要求，因此必须采用线程池进行预创建。

(3) 必须经常面对高**突发**性事件，比如Web服务器，如果有足球转播，则服务器将产生巨大的冲击。此时如果采取传统方法，则必须不停的大量产生线程，销毁线程。此时采用动态线程池可以避免这种情况的发生。

#### 13.怎么回收线程？

**pthread_join函数**

pthread_join类似于进程中的waitpid，用于等待一个给定线程的终止

![屏幕快照 2018-09-21 上午11.10.24](/Users/hanxu/Desktop/blog图片文件/屏幕快照 2018-09-21 上午11.10.24.png)

- **tid**：等待终止的线程ID。和进程不同的是，无法等待任意线程，所以不能通过指定ID参数为-1来企图等待任意线程终止
- **status**：如果该指针非空，来自所等待线程的返回值（一个指向某个对象的指针）将存入由status指向的位置

对于一个非脱离状态的线程，如果没有其它线程调用pthread_join等待线程终止，那么线程终止后的资源无法回收，会造成资源浪费，进而影响同一进程创建的线程数量

#### 14.进程->线程->协程

[——知乎阿猫](https://www.zhihu.com/question/20511233)（本质好像是[用户态线程](https://github.com/arkingc/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#3%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB)，线程与协程最大的区别在是否依赖CPU时钟发出的中断来调度，协程的调度完全由用户控制）

#### 15.线程和协程的区别？

**本质上协程就是用户空间下的线程。**

协程的调度完全由用户控制，一个线程可以有多个协程，用户创建了几个线程，然后每个线程都是循环按照指定的任务清单顺序完成不同的任务，当任务被堵塞的时候执行下一个任务，当恢复的时候再回来执行这个任务，任务之间的切换只需要保存每个任务的上下文内容，就像直接操作栈一样的，这样就完全没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快；另外协程还需要保证是非堵塞的且没有相互依赖，协程基本上不能同步通讯，多采用一步的消息通讯，效率比较高。

#### 16.守护进程、僵尸进程、孤儿进程？

**守护进程运行在后台，独立于控制终端，周期性执行某种任务，父进程为init，一般系统启动时运行；僵尸进程会占据PID等系统资源，可以通过kill其父进程，转交给init周期性调用wait操作清理**

我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

**1>孤儿进程**

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
由于孤儿进程会被init进程给收养，所以孤儿进程不会对系统造成危害

**2>僵尸进程**

一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

1)僵死进程的危害：

unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。

任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。 如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

一个进程如果只复制fork子进程而不负责对子进程进行wait()或是waitpid()调用来释放其所占有资源的话，那么就会产生很多的僵死进程，如果要消灭系统中大量的僵死进程，只需要将其父进程杀死，此时所有的僵死进程就会编程孤儿进程，从而被init所收养，这样init就会释放所有的僵死进程所占有的资源，从而结束僵死进程。

**3>守护进程**

Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。

守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。

一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。

守护进程的名称通常以d结尾，比如sshd、xinetd、crond等

#### 17.进程调度方法

 **1>短程调度准则**

调度算法的设计需要考虑如下方面（以下为从一种维度的划分）：

- 面向用户的准则：延迟（侧重于用户）
- 面向系统的准则：效果、利用率、吞吐量（侧重于系统）

**2> 优先级调度**

- 每个进程被指定一个优先级，调度程序总是优先选择具有较高优先级的进程
- 低优先级进程可能饥饿

![屏幕快照 2018-09-21 上午11.46.48](/Users/hanxu/Desktop/blog图片文件/屏幕快照 2018-09-21 上午11.46.48.png)
**3> 选择调度策略**

- **周转时间**：等待时间 + 服务时间
- **归一化周转时间**：周转时间/服务时间

**1）先来先服务(FCFS)：**

非抢占
对短进程不利（相对于I/O密集型的进程，更利于处CPU密集型的进程）；一种改进是与优先级结合，每个优先级一个队列，同一队列内部使用FCFS
**2）轮转(时间片)：**

抢占
以时间片为周期产生时钟中断，切换运行
主要设计问题是时间片的长度，太短时间片会带来频繁的进程上下文切换开销。时间片过长(比最长进程还长)，算法就退化成了FCFS
**3）最短进程优先(SPN)：**

非抢占
每次调度选择(所需总)处理时间最短的进程。可能饥饿长进程
难点在于需要估计每个进程所需要的处理时间
**4）最短剩余时间(SRT)：**

抢占
每次选择剩余处理时间最少的进程，可能饥饿长进程
也需要估计每个进程所需的处理时间。同时，维护过去的服务时间也会增加开销
**5）最高响应比(HRRN)：**

响应比 =（等待时间+要求服务时间）/ 要求服务时间,即RR=（w+s）/s=1+w/s，因此响应比一定是大于1的。

非抢占
调度选择归一化周转时间最大的进程，归一化时间越大说明进程“年龄”越大。当偏向短作业时（小分母产生大比值），长进程由于得不到服务，等待的时间不断增加，从而增大了比值，最终在竞争中可以胜出,同样需要预估每个进程所需的处理时间
**6）反馈法：**

优先级越高的队列中它的时间片就越短。

抢占
反馈法为了解决SPN、SPT和HRRN必须预估进程所需处理时间的问题(不能获得剩余执行时间就关注已经执行了的时间)。通过处罚运行时间较长进程的方法来偏向短进程。进程每被抢占一次(说明进程还未运行完，可能是个长进程)，就移入更低优先级的队列。在这种机制下，短进程在降级过多前就能运行完，长进程会一直降级，如果已经处于最低级队列，则再次被抢占后返回该队列。
这种方法的问题是长进程的周转时间可能惊人的增加，导致饥饿，一种方法是可以增加低优先级队列中进程运行的时间片，但仍可能饥饿，还有一种方法是如果在低级队列中时间过长，提升到高优先级队列中

![屏幕快照 2018-09-21 上午11.53.19](/Users/hanxu/Desktop/blog图片文件/屏幕快照 2018-09-21 上午11.53.19.png)

**4> 调度实例分析**

给出如下进程以及到达时间和服务时间：

![屏幕快照 2018-09-21 上午11.54.17](/Users/hanxu/Desktop/blog图片文件/屏幕快照 2018-09-21 上午11.54.17.png)

使用各种调度策略：

![屏幕快照 2018-09-21 上午11.54.45](/Users/hanxu/Desktop/blog图片文件/屏幕快照 2018-09-21 上午11.54.45.png)

#### 18.中断、陷阱和系统调用

（异常和中断的区别？）

![屏幕快照 2018-09-21 上午11.59.53](/Users/hanxu/Desktop/blog图片文件/屏幕快照 2018-09-21 上午11.59.53.png)

**1>中断**

这里的中断是特指来自外部的信号中断当前指令序列的执行。通常国内教材只有在特指**外部中断**时才指的是这个，而**内部异常**通常指的就是后三种.

**2>陷阱**

陷阱是有意的异常，重要的用途就是在用户程序和内核之间提供像过程调用一样的接口，称为**系统调用**，让用户程序能够访问操作系统提供服务，所以**系统调用是陷阱的一种，同时陷阱只是内部异常的一种**。在IA-32中陷阱指令有 INT n, int 3,into, bound etc.

**3>故障**

故障由错误引起，常见的比如**segment fault**, 缺页异常，如果系统能够处理，那就会回到当前指令继续执行，否则终止程序。

**4>终止**

就是不可恢复了。




